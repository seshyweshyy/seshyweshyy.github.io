<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="icon" type="image/png" href="/images/tetrisicon.png">
  <title>Tetris</title>
  <style>
    :root{--bg:#0b1220;--panel:#0f1724;--accent:#61dafb;--muted:#9aa7b2}
    *{box-sizing:border-box}
    body{margin:0;height:100vh;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071026 0%,#04121a 100%);font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    .wrap{display:flex;gap:20px;align-items:flex-start}
    .board{background:var(--panel);padding:16px;border-radius:12px;box-shadow:0 6px 30px rgba(0,0,0,.6);}
    canvas{display:block;background:#071226;border-radius:6px}
    .ui{width:260px;color:#e6eef6}
    h1{margin:0 0 12px;font-size:20px;color:var(--accent);text-align:center}
    .stats{background:rgba(255,255,255,0.03);padding:12px;border-radius:10px;margin-bottom:12px}
    .row{display:flex;justify-content:space-between;margin-bottom:8px}
    .controls{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
    button{background:#0f2130;border:1px solid rgba(255,255,255,0.04);color:#dff2ff;padding:10px;border-radius:8px;cursor:pointer}
    button.secondary{background:transparent;border:1px dashed rgba(255,255,255,0.04);color:var(--muted)}
    .next, .hold{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;margin-bottom:12px}
    .mini-canvas{width:120px;height:120px;background:#071226;border-radius:6px}
    footer{font-size:12px;color:var(--muted);text-align:center;margin-top:8px}
    .kbd{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="board">
      <canvas id="game" width="300" height="600"></canvas>
    </div>

    <div class="ui">
      <h1>TETRIS</h1>

      <div class="stats">
        <div class="row"><div>Score</div><div id="score">0</div></div>
        <div class="row"><div>Level</div><div id="level">0</div></div>
        <div class="row"><div>Lines</div><div id="lines">0</div></div>
      </div>

      <div class="next">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px"><strong>Next</strong><span class="kbd">Z/X rotate · Shift hold</span></div>
        <canvas id="next" class="mini-canvas" width="120" height="120"></canvas>
      </div>

      <div class="hold">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px"><strong>Hold</strong><button id="holdBtn" class="secondary">Hold</button></div>
        <canvas id="hold" class="mini-canvas" width="120" height="120"></canvas>
      </div>

      <div class="controls">
        <button id="start">Start / Restart</button>
        <button id="pause">Pause</button>
        <button id="soft">Soft Drop</button>
        <button id="hard">Hard Drop</button>
      </div>

      <footer>
        Controls: ← → move · Z rotate CCW · X rotate CW · ↑ rotate · ↓ soft · Space hard drop<br>
        Built: Single-file HTML/CSS/JS clone. Not an official Tetris.
      </footer>
    </div>
  </div>

  <script>
  /* ---------- TETROMINO DEFINITIONS ---------- */
  const COLS = 10, ROWS = 20, BLOCK = 30;
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  canvas.width = COLS * BLOCK;
  canvas.height = ROWS * BLOCK;
  ctx.imageSmoothingEnabled = false;

  const nextCanvas = document.getElementById('next').getContext('2d');
  const holdCanvas = document.getElementById('hold').getContext('2d');

  const SHAPES = {
    I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    J: [[1,0,0],[1,1,1],[0,0,0]],
    L: [[0,0,1],[1,1,1],[0,0,0]],
    O: [[1,1],[1,1]],
    S: [[0,1,1],[1,1,0],[0,0,0]],
    T: [[0,1,0],[1,1,1],[0,0,0]],
    Z: [[1,1,0],[0,1,1],[0,0,0]]
  };

  const COLORS = { I:'#00f0f0', J:'#0000f0', L:'#f0a000', O:'#f0f000', S:'#00f000', T:'#a000f0', Z:'#f00000' };

  /* ---------- GAME STATE ---------- */
  function createMatrix(w,h){
    const m=[]; while(h--) m.push(new Array(w).fill(0)); return m;
  }
  let grid = createMatrix(COLS, ROWS);

  function randomBag(){
    const bag = Object.keys(SHAPES);
    for(let i=bag.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[bag[i],bag[j]]=[bag[j],bag[i]]}
    return bag;
  }

  let bag = [], queue = [], hold = null, holdUsed=false;
  function refillQueue(){
    if(bag.length===0) bag = randomBag();
    while(queue.length < 5) queue.push(bag.pop());
  }

  refillQueue();

  function makePiece(type){
    return {type, matrix: SHAPES[type].map(r=>r.slice()), x: Math.floor((COLS - SHAPES[type][0].length)/2), y: 0};
  }

  let piece = makePiece(queue.shift());
  refillQueue();

  /* ---------- UTILS ---------- */
  function rotate(matrix, dir){
    // transpose
    for(let y=0;y<matrix.length;y++) for(let x=0;x<y;x++) [matrix[x][y], matrix[y][x]]=[matrix[y][x], matrix[x][y]];
    if(dir>0) matrix.forEach(row=>row.reverse()); else matrix.reverse();
  }

  function collide(grid,p){
    const m = p.matrix;
    for(let y=0;y<m.length;y++) for(let x=0;x<m[y].length;x++){
      if(m[y][x] && (grid[y + p.y] && grid[y + p.y][x + p.x]) !== 0) return true;
    }
    return false;
  }

  function merge(grid,p){
    p.matrix.forEach((row,y)=>row.forEach((val,x)=>{ if(val) grid[y + p.y][x + p.x] = p.type; }));
  }

  function clearLines(){
    let lines = 0;
    outer: for(let y=ROWS-1;y>=0;y--){
      for(let x=0;x<COLS;x++) if(!grid[y][x]) continue outer;
      const row = grid.splice(y,1)[0].fill(0);
      grid.unshift(row);
      lines++; y++; // re-check same row index
    }
    return lines;
  }

  function hardDrop(){
    while(!collide(grid,piece)) piece.y++;
    piece.y--;
    lockPiece();
  }

  function lockPiece(){
    merge(grid,piece);
    const cleared = clearLines();
    if(cleared){
      lines += cleared;
      score += calcScore(cleared, level);
      document.getElementById('score').textContent = score;
      document.getElementById('lines').textContent = lines;
      const newLevel = Math.floor(lines/10);
      if(newLevel>level){ level = newLevel; document.getElementById('level').textContent = level; }
    }
    spawnPiece();
  }

  function spawnPiece(){
    piece = makePiece(queue.shift());
    refillQueue();
    holdUsed = false;
    piece.x = Math.floor((COLS - piece.matrix[0].length)/2);
    piece.y = 0;
    if(collide(grid,piece)) {
      // game over -> reset
      playing = false; paused = false;
      showGameOver();
    }
  }

  function calcScore(linesCleared, level){
    const base = [0,100,300,500,800];
    return (base[linesCleared]||0) * (level+1);
  }

  /* ---------- DRAW ---------- */
  function drawCell(x,y,color){
    ctx.fillStyle = color;
    ctx.fillRect(x*BLOCK+1,y*BLOCK+1,BLOCK-2,BLOCK-2);
    // subtle inner highlight
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(x*BLOCK+3,y*BLOCK+3,BLOCK-6,BLOCK-6);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // background grid
    ctx.fillStyle = '#071226';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw locked
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
      const v = grid[y][x];
      if(v){ drawCell(x,y,COLORS[v]); }
    }
    // draw current piece
    piece.matrix.forEach((row,dy)=>row.forEach((val,dx)=>{ if(val){ drawCell(piece.x+dx,piece.y+dy,COLORS[piece.type]); } }));
  }

  function drawSmall(ctxRef, type){
    const size = 4; const scale = 20; ctxRef.canvas.width = 120; ctxRef.canvas.height = 120;
    ctxRef.clearRect(0,0,120,120);
    ctxRef.fillStyle = '#071226'; ctxRef.fillRect(0,0,120,120);
    if(!type) return;
    const mat = SHAPES[type];
    const w = mat[0].length, h = mat.length;
    const offsetX = Math.floor((120 - w*scale)/2);
    const offsetY = Math.floor((120 - h*scale)/2);
    mat.forEach((row,y)=>row.forEach((v,x)=>{
      if(v){
        ctxRef.fillStyle = COLORS[type];
        ctxRef.fillRect(offsetX + x*scale + 4, offsetY + y*scale + 4, scale - 8, scale - 8);
      }
    }));
  }

  /* ---------- CONTROLS ---------- */
  const keys = {};
  document.addEventListener('keydown', e=>{
    if(!playing) return;
    if(e.key === 'ArrowLeft'){ move(-1); e.preventDefault(); }
    if(e.key === 'ArrowRight'){ move(1); e.preventDefault(); }
    if(e.key === 'ArrowDown'){ soft = true; e.preventDefault(); }
    if(e.code === 'Space'){ hardDrop(); e.preventDefault(); }
    if(e.key === 'z' || e.key === 'Z'){ rotatePiece(-1); e.preventDefault(); }
    if(e.key === 'x' || e.key === 'X' || e.key === 'ArrowUp'){ rotatePiece(1); e.preventDefault(); }
    if(e.key === 'Shift'){ holdPiece(); e.preventDefault(); }
  });
  document.addEventListener('keyup', e=>{ if(e.key === 'ArrowDown') soft=false; });

  function move(dir){ piece.x += dir; if(collide(grid,piece)) piece.x -= dir; }

  function rotatePiece(dir){
    const posX = piece.x;
    rotate(piece.matrix,dir);
    // simple wall kick: try offsets
    const kicks = [0, -1, 1, -2, 2];
    for(const k of kicks){ piece.x = posX + k; if(!collide(grid,piece)) return; }
    // fail -> revert
    rotate(piece.matrix,-dir);
    piece.x = posX;
  }

  function holdPiece(){
    if(holdUsed) return; // one hold per drop
    if(!hold){ hold = piece.type; spawnFromHold(); }
    else { [hold, piece.type] = [piece.type, hold]; piece.matrix = SHAPES[piece.type].map(r=>r.slice()); piece.x = Math.floor((COLS - piece.matrix[0].length)/2); piece.y = 0; if(collide(grid,piece)){ showGameOver(); playing=false; } }
    holdUsed = true; drawSmall(holdCanvas, hold);
  }

  function spawnFromHold(){ piece = makePiece(queue.shift()); refillQueue(); piece.x = Math.floor((COLS - piece.matrix[0].length)/2); piece.y = 0; }

  /* ---------- GAME LOOP ---------- */
  let lastTime = 0; let dropCounter = 0; let dropInterval = 1000; let soft = false;
  let score = 0, lines = 0, level = 0;
  let playing = false, paused = false;

  function update(t=0){
    if(!playing || paused) { lastTime = t; requestAnimationFrame(update); return; }
    const delta = t - lastTime; lastTime = t;
    dropCounter += delta;
    const interval = soft ? 50 : Math.max(1000 - level*80, 100);
    if(dropCounter > interval){ piece.y++; if(collide(grid,piece)){ piece.y--; lockPiece(); } dropCounter = 0; }
    draw();
    drawSmall(nextCanvas, queue[0]);
    drawSmall(holdCanvas, hold);
    requestAnimationFrame(update);
  }

  function startGame(){
    grid = createMatrix(COLS, ROWS);
    bag = []; queue = []; refillQueue(); hold = null; holdUsed=false;
    piece = makePiece(queue.shift()); refillQueue();
    score = 0; lines = 0; level = 0; playing = true; paused = false;
    document.getElementById('score').textContent = score;
    document.getElementById('lines').textContent = lines;
    document.getElementById('level').textContent = level;
    lastTime = performance.now(); dropCounter = 0;
    requestAnimationFrame(update);
  }

  function showGameOver(){
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#fff'; ctx.font = '24px system-ui'; ctx.textAlign='center'; ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 10);
    ctx.font = '14px system-ui'; ctx.fillText('Press Start to play again', canvas.width/2, canvas.height/2 + 18);
  }

  document.getElementById('start').addEventListener('click', ()=>{ startGame(); });
  document.getElementById('pause').addEventListener('click', ()=>{ paused = !paused; document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause'; });
  document.getElementById('soft').addEventListener('mousedown', ()=>{ soft=true; });
  document.getElementById('soft').addEventListener('mouseup', ()=>{ soft=false; });
  document.getElementById('hard').addEventListener('click', ()=>{ hardDrop(); });
  document.getElementById('holdBtn').addEventListener('click', ()=>{ holdPiece(); });

  // initial draw
  draw(); drawSmall(nextCanvas, queue[0]); drawSmall(holdCanvas, hold);
  </script>
</body>
</html>
